import cv2
import numpy as np
import math
from gpiozero import Servo
from gpiozero import Motor

#하드웨어 설정

servo = Servo(12)
motor = Motor(forward=13, backward=19)


#카메라 및 변수 설정

cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

#STEERING_OFFSET 미세 조정: 0.20 -> 0.18
STEERING_OFFSET = 0.18
last_steering = STEERING_OFFSET 

#직선 주행 시 최대 조향 각도 제한: 0.25 (직선에서 큰 조향을 원천적으로 방지)
MAX_STEERING = 0.42 # 전체 최대값
MAX_STEERING_STRAIGHT = 0.18 # 직선 주행 시 최대값

#Lookahead 제거: 0
STEERING_LOOKAHEAD_PIXELS = 0 
#스무딩 극대화: 0.15 (직전 조향값 영향력 85%로 직진성 강화)
STEERING_SMOOTHING_ALPHA = 0.15 

#P_GAIN_STRAIGHT 최대치 적용: 0.60 
P_GAIN_STRAIGHT = 0.60


while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Camera Error")
        motor.stop()
        break
    
    #이미지 전처리

    frame = cv2.resize(frame, (720, 480))
    height, width = frame.shape[:2]
    CENTER_X = width // 2  # 320
    
    #ROI 시작점: 0.65 
    roi_y_start = int(height * 0.65) 
    roi_y_end = height 
    roi = frame[roi_y_start:roi_y_end, 0:width]
    line_draw = np.copy(roi)
    
    y_line_roi = (height - STEERING_LOOKAHEAD_PIXELS) - roi_y_start 
    y_end_roi = height - roi_y_start

    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(roi_gray, (5, 5), 0)
    
    edges = cv2.Canny(blur, 50, 150)
    #HoughLinesP Threshold 극대화: 15
    lines = cv2.HoughLinesP(edges, 
                            rho=1, 
                            theta=np.pi/180, 
                            threshold=15, 
                            minLineLength=3, 
                            maxLineGap=20)
    
    #차선 구분 및 좌표 계산 
    l_m, r_m = [], []
    l_b, r_b = [], []
    
    #차선 인식 범위 확대
    RIGHT_LANE_X_MIN = CENTER_X - 55 # 270
    LEFT_LANE_X_MAX = CENTER_X + 60  # 370
    
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0] 
            if (x2 - x1) == 0: continue
            m = (y2 - y1) / (x2 - x1) 
            y_b = y1 - m * x1 
            mid_x = (x1 + x2) / 2
            
            #차선 기울기 조건 강화: +/- 0.1
            if m > 0.1 and mid_x > RIGHT_LANE_X_MIN:
                r_m.append(m); r_b.append(y_b)
            elif m < -0.1 and mid_x < LEFT_LANE_X_MAX:
                l_m.append(m); l_b.append(y_b)

    rx, lx = 0.0, 0.0
    r_cross, l_cross = 0, 0
    
    if len(r_m) > 0:
        avg_m = np.mean(r_m)
        avg_y_b = np.mean(r_b)
        if avg_m != 0: 
            r_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = r_cross - 320 
            rx = float(er/400) 
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (r_cross, y_line_roi), (x_end_vis, y_end_roi), (255, 0, 0), 3)

    if len(l_m) > 0: 
        avg_m = np.mean(l_m)
        avg_y_b = np.mean(l_b)
        if avg_m != 0:
            l_cross = int((y_line_roi - avg_y_b) / avg_m)
            er = l_cross - 320
            lx = float(er/400) 
            x_end_vis = int((y_end_roi - avg_y_b) / avg_m)
            cv2.line(line_draw, (l_cross, y_line_roi), (x_end_vis, y_end_roi), (0, 255, 0), 3)


    #최종 조향 결정 로직 (강제 직진 모드 유지)
    P_term = 0.0
    lines_detected_both = (r_cross != 0 and l_cross != 0)
    
    if lines_detected_both:
        #직선 주행 - 강제 직진 모드(오직 STEERING_OFFSET 0.18만 반영됨)
        P_term = 0.0 
        MAX_STEERING_TEMP = MAX_STEERING_STRAIGHT
        
    elif l_cross != 0:
        #곡선 주행: 왼쪽 차선 추종 (Gain 0.5 유지)
        current_error = -lx
        P_term = current_error * 0.5
        MAX_STEERING_TEMP = MAX_STEERING
        
    elif r_cross != 0:
        #곡선 주행: 오른쪽 차선 추종 (Gain 0.7 유지)
        current_error = -rx
        P_term = current_error * 0.7
        MAX_STEERING_TEMP = MAX_STEERING
        
    else:
        #차선 미감지 시: 직전 조향값 유지 (오프셋 제외된 값)
        P_term = last_steering - STEERING_OFFSET
        MAX_STEERING_TEMP = MAX_STEERING
        
    unoffseted_steering = P_term
    final_steering = unoffseted_steering 
        
    #직선 쏠림 보정 적용 (0.18)
    final_steering += STEERING_OFFSET
        
    # EMA Smoothing 적용 (직전 조향값 영향력 85%로 극대화)
    final_steering = (final_steering * STEERING_SMOOTHING_ALPHA) + \
                     (last_steering * (1 - STEERING_SMOOTHING_ALPHA))

    
    #조향값 제한 
    if abs(final_steering) > MAX_STEERING_TEMP:
        steering = math.copysign(MAX_STEERING_TEMP, final_steering)
    else:
        steering = final_steering

    if -1.0 <= steering <= 1.0:
        servo.value = steering
        #모터 속도: 0.6
        motor.forward(0.6)
        
        last_steering = steering
        
        #직진 상태 근처일 때 last_steering 초기화 (오프셋 0.18에 맞춰서 조건 0.15 유지)
        if abs(steering - STEERING_OFFSET) < 0.15:
            last_steering = STEERING_OFFSET

    else:
        motor.stop()
        print("Steering Error")

    #화면 출력 (디버깅)
    #강제 직진 모드일 때는 타겟 X 위치가 320 (정중앙)이 됨
    target_x = 320
    if l_cross != 0 and r_cross != 0: 
        #강제 직진 모드: 목표를 중앙으로 표시
        target_x = CENTER_X 
    elif l_cross != 0: 
        target_x = l_cross + int(width * 0.3) 
    elif r_cross != 0: 
        target_x = r_cross - int(width * 0.3)
    
    cv2.circle(line_draw, (target_x, y_line_roi), 10, (0, 255, 255), -1)
    cv2.line(line_draw, (320, 0), (320, height), (255, 255, 255), 1) 

    cv2.imshow("Lane View", line_draw)
    cv2.imshow("Edges", edges) 

    if cv2.waitKey(1) == ord('q'):
        break

motor.stop()
cap.release() 
cv2.destroyAllWindows()
